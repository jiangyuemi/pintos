# Project 1: Threads

## Preliminaries

>Fill in your name and email address.

`Refrain520cc`

`EI Psy Congroo!`

`3244156674@qq.com`

>If you have any preliminary comments on your submission, notes for the
>TAs, please give them here.



>Please cite any offline or online sources you consulted while
>preparing your submission, other than the Pintos documentation, course
>text, lecture notes, and course staff.

## Before P1

管理线程状态的两个*DLL(Doubly linked list)*: `ready_list`和`all_list`, 前者记录`THREAD_READY`状态下的线程

两个特殊的线程: `initial_thread`和`idle_thread`


## Alarm Clock

>> 在 Pintos 项目中，禁用中断所能解决的唯一一类问题就是协调内核线程和中断处理程序之间的共享数据。

>> 由于中断处理程序不能休眠，因此无法获取锁。这意味着内核线程和中断处理程序之间共享的数据必须通过关闭中断来保护内核线程。

>> 本项目只需要从中断处理程序访问一点点线程状态。

>> 对于`alarm clock`来说，`timer interrupt`需要唤醒睡眠线程。

>> 在高级调度程序中，`timer interrupt`需要访问一些全局变量和每个线程变量。从内核线程访问这些变量时，需要禁用中断，以防止定时器中断干扰。

>> 在关闭中断时，要注意尽可能减少代码量。

>> 否则，您可能会丢失一些重要内容，如`timer ticks`或`input events`

>> 关闭中断也会增加中断处理延迟，如果过度，会让机器感觉迟钝。

>> 在`synch.c`中的同步原语本身就是通过禁用中断实现的。

>> 可能需要增加禁用中断时运行的代码量，但仍应尽量减少。

>> 禁用中断对调试很有用，如果你想确保某段代码不被中断的话。

>> 在提交项目之前，应删除调试代码。(不要直接注释掉，因为这样会使代码难以阅读）。

>> 提交的项目中不应有繁忙等待。

>> 调用 `thread_yield()` 的紧密循环是繁忙等待的一种形式。\

```



pass tests/threads/mlfqs-fair-2
FAIL tests/threads/mlfqs-fair-20
FAIL tests/threads/mlfqs-nice-2
FAIL tests/threads/mlfqs-nice-10
FAIL tests/threads/mlfqs-block





pass tests/threads/mlfqs-fair-2
pass tests/threads/mlfqs-fair-20
FAIL tests/threads/mlfqs-nice-2
FAIL tests/threads/mlfqs-nice-10
FAIL tests/threads/mlfqs-block
20 of 27 tests failed.
```

#### DATA STRUCTURES

>A1: Copy here the declaration of each new or changed struct or struct member, global or static variable, typedef, or enumeration.  Identify the purpose of each in 25 words or less.



#### ALGORITHMS

>A2: Briefly describe what happens in a call to timer_sleep(),
>including the effects of the timer interrupt handler.



>A3: What steps are taken to minimize the amount of time spent in
>the timer interrupt handler?



#### SYNCHRONIZATION

>A4: How are race conditions avoided when multiple threads call
>timer_sleep() simultaneously?



>A5: How are race conditions avoided when a timer interrupt occurs
>during a call to timer_sleep()?



#### RATIONALE

>A6: Why did you choose this design?  In what ways is it superior to
>another design you considered?



## Priority Scheduling

#### DATA STRUCTURES

>B1: Copy here the declaration of each new or changed struct or struct member, global or static variable, typedef, or enumeration.  Identify the purpose of each in 25 words or less.



>B2: Explain the data structure used to track priority donation.
>Use ASCII art to diagram a nested donation.  (Alternately, submit a
>.png file.)



#### ALGORITHMS

>B3: How do you ensure that the highest priority thread waiting for
>a lock, semaphore, or condition variable wakes up first?



>B4: Describe the sequence of events when a call to lock_acquire()
>causes a priority donation.  How is nested donation handled?



>B5: Describe the sequence of events when lock_release() is called
>on a lock that a higher-priority thread is waiting for.



#### SYNCHRONIZATION

>B6: Describe a potential race in thread_set_priority() and explain
>how your implementation avoids it.  Can you use a lock to avoid
>this race?



#### RATIONALE

>B7: Why did you choose this design?  In what ways is it superior to
>another design you considered?



## Advanced Scheduler

#### DATA STRUCTURES

>C1: Copy here the declaration of each new or changed struct or struct member, global or static variable, typedef, or enumeration.  Identify the purpose of each in 25 words or less.



#### ALGORITHMS

>C2: How is the way you divided the cost of scheduling between code
>inside and outside interrupt context likely to affect performance?



#### RATIONALE

>C3: Briefly critique your design, pointing out advantages and
>disadvantages in your design choices.  If you were to have extra
>time to work on this part of the project, how might you choose to
>refine or improve your design?



>C4: The assignment explains arithmetic for fixed-point math in
>detail, but it leaves it open to you to implement it.  Why did you
>decide to implement it the way you did?  If you created an
>abstraction layer for fixed-point math, that is, an abstract data
>type and/or a set of functions or macros to manipulate fixed-point
>numbers, why did you do so?  If not, why not?